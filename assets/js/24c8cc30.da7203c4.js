"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[439],{5456:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>u,frontMatter:()=>r,metadata:()=>d,toc:()=>l});var i=n(4848),s=n(8453);const r={sidebar_position:10,sidebar_label:"0010 Context Builders",description:"Azure Function Context Builders",status:"accepted",contact:"mgupta83",date:new Date("2024-07-02T00:00:00.000Z"),deciders:"mgupta83",consulted:"nnoce14"},o="Azure Function Context Builders",d={id:"decisions/context-builders",title:"Azure Function Context Builders",description:"Azure Function Context Builders",source:"@site/docs/decisions/0010-context-builders.md",sourceDirName:"decisions",slug:"/decisions/context-builders",permalink:"/docs/decisions/context-builders",draft:!1,unlisted:!1,editUrl:"https://github.com/simnova/ownercommunity/tree/main/docusaurus/docs/decisions/0010-context-builders.md",tags:[],version:"current",sidebarPosition:10,frontMatter:{sidebar_position:10,sidebar_label:"0010 Context Builders",description:"Azure Function Context Builders",status:"accepted",contact:"mgupta83",date:"2024-07-02T00:00:00.000Z",deciders:"mgupta83",consulted:"nnoce14"},sidebar:"tutorialSidebar",previous:{title:"0009 React Router Loadeer",permalink:"/docs/decisions/react-router-loaders"},next:{title:"ADR Template",permalink:"/docs/decisions/adr-template"}},c={},l=[{value:"Problem Statement",id:"problem-statement",level:2},{value:"Decision Drivers",id:"decision-drivers",level:2},{value:"Decision",id:"decision",level:2},{value:"AppContextBuilder",id:"appcontextbuilder",level:3},{value:"Seedwork Context Builders",id:"seedwork-context-builders",level:3},{value:"Route Context Builders",id:"route-context-builders",level:3},{value:"Implementing Route Context Builder",id:"implementing-route-context-builder",level:3},{value:"Extending Context Interfaces and Initialization",id:"extending-context-interfaces-and-initialization",level:3}];function a(e){const t={code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.h1,{id:"azure-function-context-builders",children:"Azure Function Context Builders"}),"\n",(0,i.jsx)(t.h2,{id:"problem-statement",children:"Problem Statement"}),"\n",(0,i.jsx)(t.p,{children:"Design a structured hierarchy for Context Builders to allow for both general and custom-use cases, depending on the needs of the given Azure Function."}),"\n",(0,i.jsx)(t.p,{children:"We initially only designed our Context Builder specifically for our GraphQL endpoint, which is served as an HTTP Azure Function. We needed to accommodate Context Builders for Queue and Timer Azure Functions, as well as a generic HTTP context builder for any other HTTP endpoints we may have."}),"\n",(0,i.jsx)(t.h2,{id:"decision-drivers",children:"Decision Drivers"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Flexibility"}),": Different Azure Functions have distinct needs for their context objects. Each type of Azure Function has a seedwork file for a context builder for that specific function type. These classes can be extended as needed to accommodate for any use case a specific function may have."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Abstraction"}),": Context Builders inherit from a shared ",(0,i.jsx)(t.code,{children:"BaseContextBuilder"})," class which contains shared logic common to all context builders."]}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"decision",children:"Decision"}),"\n",(0,i.jsx)(t.p,{children:"We will implement abstract Context Builder classes for each type of Azure Function. These are seedwork files that are intended to be portable to other projects. These abstract classes can be extended to serve the needs of specific Azure Functions for any given project."}),"\n",(0,i.jsxs)(t.p,{children:["There are three layers to our hierarchy. The first being the ",(0,i.jsx)(t.code,{children:"AppContextBuilder"}),", which is designed to encapsulate the domain rules of the project and is specific to the needs of the project. This ",(0,i.jsx)(t.code,{children:"AppContext"})," is used to make determinations regarding business logic throughout the domain layer of the project."]}),"\n",(0,i.jsxs)(t.p,{children:["The second layer is the seedwork Context Builder classes, which are ",(0,i.jsx)(t.code,{children:"HttpContextBuilder"}),", ",(0,i.jsx)(t.code,{children:"QueueContextBuilder"}),", and ",(0,i.jsx)(t.code,{children:"TimerContextBuilder"}),". There is a fourth class called ",(0,i.jsx)(t.code,{children:"BaseContextBuilder"})," which is extended by the other three and contains common fields and functions shared across all context builders. These classes are abstract and intended to be portable across all projects."]}),"\n",(0,i.jsxs)(t.p,{children:["The third layer is the route Context Builder classes which extend the abstract classes to provide the implementation details that are specific to the project. In this case, those functions are ",(0,i.jsx)(t.code,{children:"setAppContext()"})," and ",(0,i.jsx)(t.code,{children:"setVerifiedUser()"})," which depend on the azure function the context will be used for as well as implementation details specific to the project."]}),"\n",(0,i.jsx)(t.h3,{id:"appcontextbuilder",children:"AppContextBuilder"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["Location: ",(0,i.jsx)(t.code,{children:"/src/app/init/app-context-builder.ts"})]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["Shared structure for all Context Builder classes. Exists as a member field on the abstract context builder classes. The idea is this context is referenced all throughout the domain layer in regards to business logic and making decisions based off the permissions of the user. The fields on this context may vary as they are domain specific to each project, and thus cannot be 100% portable. The ",(0,i.jsx)(t.code,{children:"AppContextBuilder"})," will exist in all projects, but it's interface and implementation details will be specific to each project."]}),"\n",(0,i.jsx)(t.h3,{id:"seedwork-context-builders",children:"Seedwork Context Builders"}),"\n",(0,i.jsx)(t.p,{children:"Abstract classes which are meant to serve as a generic template for Route Context Builders to extend based on the type of Azure Function being used. Currently, there are three types of Seedwork Context Builders:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"HttpContextBuilder"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["Location: ",(0,i.jsx)(t.code,{children:"/seedwork/seedwork-az-function-handler_http/http-context-builder.ts"})]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"QueueContextBuilder"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["Location: ",(0,i.jsx)(t.code,{children:"/seedwork/seedwork-az-function-handler_http/http-context-builder.ts"})]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"TimerContextBuilder"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["Location: ",(0,i.jsx)(t.code,{children:"seedwork/seedwork-az-function-handler_timer/timer-context-builder.ts"})]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["The functions on the classes as well as the interfaces will be consistent across all projects.\nThere is also an additional class ",(0,i.jsx)(t.code,{children:"BaseContextBuilder"})," which contains shared logic for all the Seedwork Context Builder classes and is extended by them."]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"BaseContextBuilder"})," Location: ",(0,i.jsx)(t.code,{children:"/seedwork/seedwork-az-function-handler_base/base-context-builder.ts"})]}),"\n"]}),"\n",(0,i.jsx)(t.h3,{id:"route-context-builders",children:"Route Context Builders"}),"\n",(0,i.jsxs)(t.p,{children:["These classes extend one of the Seedwork Context Builder classes depending on the type of Azure Function. Their implementation is specific to each project, depending on the use case and needs of that Azure Function. A common one we will be using in our projects is ",(0,i.jsx)(t.code,{children:"GraphqlContextBuilder"}),", which extends the seedwork class ",(0,i.jsx)(t.code,{children:"HttpContextBuilder"}),", since it is an HTTP Azure Function endpoint."]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"GraphqlContextBuilder"})," Location: ",(0,i.jsx)(t.code,{children:"/src/graphql/init/graphql-context-builder.ts"})]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["These Route Context Builders are also meant to be flexible. If we have multiple queue or timer functions, we can create a ",(0,i.jsx)(t.code,{children:"QueueContextBuilderImpl"})," class which can be used by multiple different Azure Functions. So the idea is we can have generic Route Context Builders, and also be able to create specific ones for more involved Azure Functions as needed."]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"QueueContextBuilderImpl"})," Location: ",(0,i.jsx)(t.code,{children:"/src/queue/init/queue-context-builder-impl.ts"})]}),"\n"]}),"\n",(0,i.jsx)(t.h3,{id:"implementing-route-context-builder",children:"Implementing Route Context Builder"}),"\n",(0,i.jsx)(t.p,{children:"Here is a quick example of implementing a route context builder for a generic Azure Function queue."}),"\n",(0,i.jsxs)(t.p,{children:["To begin, extend the seedwork class ",(0,i.jsx)(t.code,{children:"QueueContextBuilder"}),"."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-typescript",children:"export class QueueContextBuilderImpl extends QueueContextBuilder implements QueueContext {}\n"})}),"\n",(0,i.jsxs)(t.p,{children:["There are two abstract methods on ",(0,i.jsx)(t.code,{children:"QueueContextBuilder"})," which need to be implemented: ",(0,i.jsx)(t.code,{children:"setVerifiedUser()"})," and ",(0,i.jsx)(t.code,{children:"setAppContext()"}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["The notion of a ",(0,i.jsx)(t.code,{children:"VerifiedUser"})," and ",(0,i.jsx)(t.code,{children:"AppContext"})," will exist across all projects. However, the implementations of these are specific to each project, and vary depending on the type of Azure Function being used."]}),"\n",(0,i.jsxs)(t.p,{children:["In this case, the ",(0,i.jsx)(t.code,{children:"VerifiedUser"}),' is a "SYSTEM" instead of being an authorized user through a JWT. ',(0,i.jsx)(t.code,{children:"setVerifiedUser()"})," can be implemented like this."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-typescript",children:"protected async setVerifiedUser(): Promise<void> {\n    this._verifiedUser = {\n        verifiedJWT: {},\n        openIdConfigKey: 'SYSTEM'\n    };\n}\n"})}),"\n",(0,i.jsxs)(t.p,{children:["For ",(0,i.jsx)(t.code,{children:"setAppContext()"}),", the ",(0,i.jsx)(t.code,{children:"AppContextBuilder"})," is constructed and initialized. In this case, some of the constructor fields are null due to ",(0,i.jsx)(t.code,{children:"QueueContextBuilderImpl"})," being a system user. This is specific to the project and the constructor for ",(0,i.jsx)(t.code,{children:"AppContextBuilder"})," will be different in your case."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-typescript",children:"protected async setAppContext(): Promise<void> {\n    this._appContext = new AppContextBuilder(\n        this._verifiedUser,\n        null,\n        null,\n        this._infrastructureServices\n    );\n    await this._appContext.init();\n}\n"})}),"\n",(0,i.jsx)(t.p,{children:"Here is the class all together."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-typescript",children:'import { InvocationContext } from "@azure/functions";\nimport { QueueContext, QueueContextBuilder } from "../../../seedwork/seedwork-az-function-handler_queue/queue-context-builder";\nimport { AppContextBuilder } from "../../app/init/app-context-builder";\nimport { InfrastructureServicesBuilder } from "../../init/infrastructure-services-builder";\n\nexport class QueueContextBuilderImpl extends QueueContextBuilder implements QueueContext {\n  constructor(queueItem: any, context: InvocationContext, infrastructureServices: InfrastructureServicesBuilder) {\n    super(queueItem, context, infrastructureServices);\n  }\n\n  protected async setVerifiedUser(): Promise<void> {\n    this._verifiedUser = {\n      verifiedJWT: {},\n      openIdConfigKey: \'SYSTEM\'\n    };\n  }\n\n  protected async setAppContext(): Promise<void> {\n    this._appContext = new AppContextBuilder(\n      this._verifiedUser,\n      null,\n      null,\n      this._infrastructureServices\n    );\n    await this._appContext.init();\n  }\n}\n'})}),"\n",(0,i.jsx)(t.h3,{id:"extending-context-interfaces-and-initialization",children:"Extending Context Interfaces and Initialization"}),"\n",(0,i.jsx)(t.p,{children:"For more involved Azure Functions which may require additional fields to be present on the context, you are able to extend the generic context interfaces defined in the seedwork files."}),"\n",(0,i.jsxs)(t.p,{children:["In this example, we will go through the ",(0,i.jsx)(t.code,{children:"GraphqlContextBuilder"})," class to showcase how to extend the context interface as well as provide additional functionality on the context initialization."]}),"\n",(0,i.jsxs)(t.p,{children:["Since our GraphQL Azure Function is an HTTP endpoint, we implement the ",(0,i.jsx)(t.code,{children:"GrapqhlContext"})," interface by extending the ",(0,i.jsx)(t.code,{children:"HttpContext"})," interface, which provides some common fields needed for all HTTP contexts such as the ",(0,i.jsx)(t.code,{children:"HttpRequest"})," object."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-typescript",children:"export interface GraphqlContext extends HttpContext {\n  communityId: string;\n}\n"})}),"\n",(0,i.jsxs)(t.p,{children:["Now instead of having the class implement ",(0,i.jsx)(t.code,{children:"HttpContext"}),", it implements the ",(0,i.jsx)(t.code,{children:"GraphqlContext"})," interface.\nTherefore, whichever fields are exposed on the ",(0,i.jsx)(t.code,{children:"GraphqlContext"})," can be used in the handler for the Azure Function."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-typescript",children:"export class GraphqlContextBuilder extends HttpContextBuilderImpl implements GraphqlContext {\n"})}),"\n",(0,i.jsxs)(t.p,{children:["If necessary, the ",(0,i.jsx)(t.code,{children:"init()"})," method from ",(0,i.jsx)(t.code,{children:"BaseContextBuilder"})," can be overridden if some additional steps are necessary on context startup. In the case of ",(0,i.jsx)(t.code,{children:"GraphqlContextBuilder"}),", we need to modify some headers on the request object."]}),"\n",(0,i.jsxs)(t.p,{children:["We can define a method on the class to modify the request object, which is a member on the class due to inheritance from the ",(0,i.jsx)(t.code,{children:"HttpContextBuilder"}),"."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-typescript",children:"private async setReqHeaders(): Promise<void> {\n    this._req.headers.set('x-ms-privatelink-id', '');\n    this._req.headers.set('server', null);\n}\n"})}),"\n",(0,i.jsxs)(t.p,{children:["To ensure this method is invoked on context startup, we can override the ",(0,i.jsx)(t.code,{children:"init()"})," method defined in ",(0,i.jsx)(t.code,{children:"BaseContextBuilder"}),", and use ",(0,i.jsx)(t.code,{children:"super.init()"})," to make sure that method is still called on startup, so the ",(0,i.jsx)(t.code,{children:"GraphqlContextBuilder"})," behaves correctly."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-typescript",children:"public async init() {\n    // execute following in order\n    await this.setReqHeaders();\n    await super.init();\n}\n"})})]})}function u(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(a,{...e})}):a(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>d});var i=n(6540);const s={},r=i.createContext(s);function o(e){const t=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function d(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),i.createElement(r.Provider,{value:t},e.children)}}}]);